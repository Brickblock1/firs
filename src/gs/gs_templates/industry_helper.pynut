// this is all prototype stuff as of Jan 2023, nothing here is proper lib

function firs::GetIndustryTypeCount(industry_type)
{
    local industry_list = GSIndustryList();
    local count = 0;
    foreach (industry, _ in industry_list) {
        if (GSIndustry.GetIndustryType(industry) == industry_type) {
            count++;
        }
    }
    return count;
}

function firs::BuildIndustryTypeInTown(industry_type, town)
{
    // write our own version of prospecting, scoped to a town

	// get a tile list, filter it, then randomise it
	local tile_list = GSTileList();
    // the map contains a row of void or water tiles around it (depending on freeform map edge settings), so our rect is pushed in by 1 tile row/col  on all sides
    tile_list.AddRectangle(GSMap.GetTileIndex(1, 1), GSMap.GetTileIndex(GSMap.GetMapSizeX() - 2, GSMap.GetMapSizeY() - 2));

    // remove water tiles, if we want water industries, we'll need to deal with that later
	tile_list.Valuate(GSTile.IsWaterTile);
	tile_list.KeepValue(0);

	tile_list.Valuate(GSTile.IsBuildable);
	tile_list.KeepValue(1);

    tile_list.Valuate(GSBase.RandItem);
	tile_list.Sort(GSList.SORT_BY_VALUE, GSList.SORT_DESCENDING);

    local result = false;
    foreach (tile, _ in tile_list) {
        if (GSTile.GetClosestTown(tile) == town) {
            local tm = GSTestMode();
            if (GSIndustryType.BuildIndustry(industry_type, tile) == true) {
                Log.Info("cabbage");
                local foo = GSExecMode();
                GSIndustryType.BuildIndustry(industry_type, tile);
                result = true;
                break;
            }
        }
    }
    return result
}


function firs::BuildAnIndustryTypeIfTargetCountNotMet(industry_type, target_count)
{
    local num_industries_to_build = target_count - firs.GetIndustryTypeCount(industry_type);
    if (num_industries_to_build > 0) {
        for (local i = 0; i < num_industries_to_build; i++) {
            Log.Info("need to build some " + GSIndustryType.GetName(industry_type) + " industries...");
            GSIndustryType.ProspectIndustry(industry_type);
        }
    }
}

function count_farms()
{
    Log.Info("counting farms...");
    local time_start = GSDate.GetSystemTime();
    local farm_id = GSIndustryType.ResolveNewGRFID(firs.grfid, firs.industries.farm.numeric_id);
    local farm_count = firs.GetIndustryTypeCount(farm_id);
    local town_list = GSTownList();
    foreach (town, _ in town_list) {
        Log.Info(firs.BuildIndustryTypeInTown(farm_id, town));
    }
    Log.Info("elapsed time: " + (GSDate.GetSystemTime() - time_start));
}

function count_scrap_yards()
{
    local time_start = GSDate.GetSystemTime();
    local scrap_yard = GSIndustryType.ResolveNewGRFID(firs.grfid, firs.industries.scrap_yard.numeric_id);
    local towns_with_scrap_yards = {};
    local industry_list = GSIndustryList();
    foreach (industry, _ in industry_list) {
        if (GSIndustry.GetIndustryType(industry) == scrap_yard) {
            local industry_town = GSTile.GetClosestTown(GSIndustry.GetLocation(industry));
            towns_with_scrap_yards[industry_town] <- true;
        }
    }
    local town_list = GSTownList();
    foreach (town, _ in town_list) {
        if (town in towns_with_scrap_yards) {
            Log.Info(GSTown.GetName(town) + " has a scrap yard");
        } else if (GSTown.GetPopulation(town) < 400) {
            // ^^ this 400 would be fetched from the python industry definition ideally (totally possible via templating or FIRS -> GS industry structure)
            continue;
        } else {
            Log.Info(GSTown.GetName(town) + " needs a scrap yard");
            foreach (tile, _ in areas.towns[town]) {
                if (GSIndustryType.BuildIndustry(scrap_yard, tile)) {
                    break;
                }
            }
        }

    }
    //firs.BuildAnIndustryTypeIfTargetCountNotMet(scrap_yard_id, (GSTown.GetTownCount() / 3));
    Log.Info("elapsed time: " + (GSDate.GetSystemTime() - time_start));
}
