// this is all prototype stuff as of Jan 2023, nothing here is proper lib

function firs::GetIndustryTypeCount(industry_type)
{
    local industry_list = GSIndustryList();
    local count = 0;
    foreach (industry, _ in industry_list) {
        if (GSIndustry.GetIndustryType(industry) == industry_type) {
            count++;
        }
    }
    return count;
}

function firs::BuildIndustryTypeInTown(industry_type, town)
{
    // write our own version of prospecting, scoped to a town

    // this isn't actually scoped to the town, it's just a circle around it, we'll need to filter by GetClosestTown later
    local town_circular_area = Circle2(GSTown.GetLocation(town), 32).GetTiles();

    local result = false;
    do {
        local rand_index = GSBase.RandRange(town_circular_area.len());
        local tile = town_circular_area[rand_index];
        town_circular_area.remove(rand_index);
        if (GSTile.GetClosestTown(tile) == town) {
            local tm = GSTestMode();
            if (GSIndustryType.BuildIndustry(industry_type, tile) == true) {
                local foo = GSExecMode();
                GSIndustryType.BuildIndustry(industry_type, tile);
                result = true;
                break;
            }
        }
    }
    while (town_circular_area.len() > 0);
    return result
}


function firs::BuildAnIndustryTypeIfTargetCountNotMet(industry_type, target_count)
{
    local num_industries_to_build = target_count - firs.GetIndustryTypeCount(industry_type);
    if (num_industries_to_build > 0) {
        for (local i = 0; i < num_industries_to_build; i++) {
            Log.Info("need to build some " + GSIndustryType.GetName(industry_type) + " industries...");
            GSIndustryType.ProspectIndustry(industry_type);
        }
    }
}

function count_farms()
{
    Log.Info("counting farms...");
    local time_start = GSDate.GetSystemTime();
    local farm_id = GSIndustryType.ResolveNewGRFID(firs.grfid, firs.industries.farm.numeric_id);
    local farm_count = firs.GetIndustryTypeCount(farm_id);
    local town_list = GSTownList();
    foreach (town, _ in town_list) {
        local farm_built = firs.BuildIndustryTypeInTown(farm_id, town);
        if (farm_built == false) {
            Log.Info("Couldn't build farm in " + GSTown.GetName(town));
        }
    }
    Log.Info("elapsed time: " + (GSDate.GetSystemTime() - time_start));
}

function count_scrap_yards()
{
    local time_start = GSDate.GetSystemTime();
    local scrap_yard = GSIndustryType.ResolveNewGRFID(firs.grfid, firs.industries.scrap_yard.numeric_id);
    local towns_with_scrap_yards = {};
    local industry_list = GSIndustryList();
    foreach (industry, _ in industry_list) {
        if (GSIndustry.GetIndustryType(industry) == scrap_yard) {
            local industry_town = GSTile.GetClosestTown(GSIndustry.GetLocation(industry));
            towns_with_scrap_yards[industry_town] <- true;
        }
    }
    local town_list = GSTownList();
    foreach (town, _ in town_list) {
        if (town in towns_with_scrap_yards) {
            Log.Info(GSTown.GetName(town) + " has a scrap yard");
        } else if (GSTown.GetPopulation(town) < 400) {
            // ^^ this 400 would be fetched from the python industry definition ideally (totally possible via templating or FIRS -> GS industry structure)
            continue;
        } else {
            Log.Info(GSTown.GetName(town) + " needs a scrap yard");
            foreach (tile, _ in areas.towns[town]) {
                if (GSIndustryType.BuildIndustry(scrap_yard, tile)) {
                    break;
                }
            }
        }

    }
    //firs.BuildAnIndustryTypeIfTargetCountNotMet(scrap_yard_id, (GSTown.GetTownCount() / 3));
    Log.Info("elapsed time: " + (GSDate.GetSystemTime() - time_start));
}
