/*
    Representation of FIRS state for GS
    - industries
    - economies
    - etc
*/

class FIRS {
    /* class just to namespace functions */

    function Init() {
        // this is relatively expensive, and is designed to only run at game start / reload

        // note that this creates a table in root
        // not designed to return a class instance
        // firs is a singleton, and allegedly a table with slots is more efficient for that case than a singleton class instance
        ::firs <- {};

        firs.grfid <- ${gs_helper.get_grfid()};

        firs.industries <- {};

        /* initial configuration of industry properties */
        <tal:industries repeat="industry registered_industries">
            firs.industries["${industry.id}"] <- VulcanIndustrySpec(
                ${industry.numeric_id},
                GSIndustryType.ResolveNewGRFID(firs.grfid,
                ${industry.numeric_id}),
                ${industry.vulcan.get_economy_variations_as_gs_table()}
            );
        </tal:industries>

        firs.economies <- {};
        <tal:economies repeat="economy registered_economies">
            local economy = {};
            economy.id <- "${economy.id}";
            economy.numeric_id <- ${economy.numeric_id};
            economy.fingerprint <- "${gs_helper.get_economy_fingerprint(registered_industries, economy)}";
            firs.economies["${economy.id}"] <- economy;
        </tal:economies>


        // !! this function doesn't need to be in the firs structure, it's to be used once at game start?
        firs.detect_the_active_economy <- function()
        /* uses fingerprinting to detect and return the economy id */
        {
            Log.Info("detect_the_active_economy called; this is expensive, should only be done at game start");
            local industry_types_list = GSIndustryTypeList();
            local industry_type_ids = [];
            local economy_matched = false;
            foreach (industry_type, _ in industry_types_list) {
                if (economy_matched == true) {
                    break;
                }
                local industry_fingerprint = "Accepts:"
                local accepted_cargo_as_labels = [];
                foreach (cargo, _ in GSIndustryType.GetAcceptedCargo(industry_type)) {
                    accepted_cargo_as_labels.push(GSCargo.GetCargoLabel(cargo));
                }
                accepted_cargo_as_labels.sort();
                foreach (cargo in accepted_cargo_as_labels) {
                    industry_fingerprint = industry_fingerprint + " " + cargo;
                }
                industry_fingerprint = industry_fingerprint + " Produces:";
                local produced_cargo_as_labels = [];
                foreach (cargo, _ in GSIndustryType.GetProducedCargo(industry_type)) {
                    produced_cargo_as_labels.push(GSCargo.GetCargoLabel(cargo));
                }
                produced_cargo_as_labels.sort();
                foreach (cargo in produced_cargo_as_labels) {
                    industry_fingerprint = industry_fingerprint  + " " + cargo;
                }
                foreach (economy_id, economy  in firs.economies) {
                    if (economy.fingerprint == industry_fingerprint) {
                        Log.Info("Fingerprinting: FIRS economy ID is " + economy_id, Log.LVL_INFO);
                        economy_matched = true;
                        return economy;
                    }
                }
            }
        }

        firs.active_economy <- firs.detect_the_active_economy();

        // !! might there be a more efficient way to do this than copying the industries around?
        firs.active_economy.industries <- {}
        foreach (industry_id, industry_spec in firs.industries) {
            if (firs.active_economy.id in industry_spec.economy_variations) {
                firs.active_economy.industries[industry_id] <- industry_spec;
            }
        }

        firs.active_economy.get_industry_ids_sorted_by_name <- function() {
            local cmp_name = function(a, b) {
                local name_a = GSIndustryType.GetName(firs.industries[a].global_id);
                local name_b = GSIndustryType.GetName(firs.industries[b].global_id);
                if (name_a > name_b) return 1
                else if (name_a < name_b) return -1
                return 0;
            }
            // can't sort on tables, so sort on the keys alone
            local result = [];
            foreach (industry_id, industry_spec in firs.active_economy.industries) {
                result.append(industry_id);
            }
            result.sort(cmp_name);
            return result;
        }

        // really we should have a way to get the name string from the economy (via lang and maybe a specific method)
        if (firs.active_economy.id == "STEELTOWN") {
            Log.Info("It's Steeltown");
        }
        // but eh, let's press on
    }
}
