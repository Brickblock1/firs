class VulcanTownControl {
    /* structure for town control */

    function Init() {
        // note that this creates a table in root
        // not designed to return a class instance
        // vulcan_town_control is a singleton, and allegedly a table with slots is more efficient for that case than a singleton class instance
        ::vulcan_town_control <- {};
        vulcan_town_control.towns <- {};
        local town_list = GSTownList();
        foreach (town, _ in town_list) {
            vulcan_town_control.towns[town] <- VulcanTown(town);
        }
        VulcanTownControl.RunPeriodicProcessing("Init");
    }

    function RunPeriodicProcessing(caller_type) {
        local time_start = GSDate.GetSystemTime();
        Log.Info("--");
        Log.Info("Town periodic processing...");
        VulcanTownControl.UpdateCargoMonitors();
        VulcanTownControl.SetGrowthRates();
        VulcanTownControl.SetTownWindowTexts();
        if (caller_type != "Init") {
            VulcanTownControl.UpdateTownStoryPages();
        }
        Log.Info("Town periodic processing done. Elapsed time: " + (GSDate.GetSystemTime() - time_start));
    }

    function UpdateCargoMonitors() {
        // !! there might be too much abstraction here, possibly we could fold this into RunPeriodicProcessing()
        foreach (vulcan_town in vulcan_town_control.towns) {
            vulcan_town.UpdateCargoMonitors();
        }
    }

    function SetGrowthRates() {
        // !! there might be too much abstraction here, possibly we could fold this into RunPeriodicProcessing()
        Log.Info("...setting town growth rates");
        foreach (vulcan_town in vulcan_town_control.towns) {
            vulcan_town.SetGrowthRate();
        }
    }

    function SetTownWindowTexts() {
        // !! there might be too much abstraction here, possibly we could fold this into RunPeriodicProcessing()
        Log.Info("...setting town window texts");
        foreach (vulcan_town in vulcan_town_control.towns) {
            vulcan_town.SetTownWindowText();
        }
    }

    function UpdateTownStoryPages() {
        // !! there might be too much abstraction here, possibly we could fold this into RunPeriodicProcessing()
        Log.Info("...updating town story pages");
        foreach (vulcan_town in vulcan_town_control.towns) {
            vulcan_town.UpdateTownStoryPage();
        }
    }
}

class VulcanTown {
    /* stores extended info / metadata about a town instance */

    // store the numeric town id as we may need it for looking up other things
    // town id is also available as the key in vulcan_town_control.towns
    town = null;
    required_cargos = null;

    constructor(town) {
        this.town = town;
        // !! temp cargos
        this.required_cargos = ["PASS", "CMNT", "VEHI", "FOOD"];
    }

    function UpdateCargoMonitors() {
        // !! cargo monitor setup needs to be made multiple monitors, and wrapped in a function
        // vulcan_town_control.cargo_monitor <- GSCargoMonitor.GetTownDeliveryAmount(0, 0, this.town, true);
        // !! will need to monitor all companies
        Log.Info("Cargo monitor for " + GSTown.GetName(this.town));
        foreach (cargo_label in required_cargos) {
            local cargo = firs.active_economy.cargo_ids_by_label[cargo_label];
            local company = 0;
            Log.Info("..." + cargo_label + ": " + GSCargoMonitor.GetTownDeliveryAmount(company, cargo, this.town, true));
        }
    }

    function SetGrowthRate() {
        // !! GSTown.SetGrowthRate(this.town, GSTown.TOWN_GROWTH_NORMAL);
        GSTown.SetGrowthRate(this.town, GSTown.TOWN_GROWTH_NONE);
    }

    function SetTownWindowText() {
        local text = GSText(GSText.STR_CABBAGE_TOWN, this.town);
        GSTown.SetText(this.town, text);
    }

    function UpdateTownStoryPage() {
        vulcan_town_control.story_pages[this.town].UpdatePage(this);
    }

}

class VulcanTownStoryBook {

    function Init() {
        // note that this creates a table in root
        // not designed to return a class instance
        // vulcan_town_story_book is a singleton, and allegedly a table with slots is more efficient for that case than a singleton class instance
        vulcan_town_control.story_pages <- {};
        VulcanTownStoryBook.AddTownStoryPages();
    }

    function AddTownStoryPages() {
        foreach (town, vulcan_town in vulcan_town_control.towns) {
            vulcan_town_control.story_pages[town] <- VulcanTownStoryPage(vulcan_town);
        }
    }
}

class VulcanTownStoryPage {

    // keep a copy of the story page (for convenience)
    story_page = null
    page_elements = null

    constructor(vulcan_town) {
        local town_name = GSTown.GetName(vulcan_town.town);
        this.story_page = GSStoryPage.New(GSCompany.COMPANY_INVALID, "Town: " + town_name);
        // define the elements
        this.page_elements = {};
        this.page_elements["display_test"] <- {
            reference = null,
            text_method = this.TestCabbage
        };
        this.page_elements["display_growth_rate"] <- {
            reference = null,
            text_method = this.DisplayGrowthRate
        };
        // add the elements
        foreach (page_element_name, page_element in this.page_elements) {
            this.page_elements[page_element_name].reference = GSStoryPage.NewElement(this.story_page, GSStoryPage.SPET_TEXT, 1, page_element.text_method(vulcan_town));
        }
    }

    function TestCabbage(vulcan_town) {
        local cabbage = ["Ham", "Eggs", "Popeye", "Alligator", "Zebedee", "The KLF"][GSBase.RandRange(5)];
        return GSText(GSText.STR_TOWN_STORY_PAGE_TEST, cabbage);
    }

    function DisplayGrowthRate(vulcan_town) {
        if (GSTown.GetGrowthRate(vulcan_town.town) == GSTown.TOWN_GROWTH_NONE) {
            local town_name = GSTown.GetName(vulcan_town.town);
            Log.Info(town_name + " is not growing");
        }
        return GSText(GSText.STR_TOWN_STORY_PAGE_GROWTH_RATE, GSTown.GetGrowthRate(vulcan_town.town).tostring());
    }

    function UpdatePage(vulcan_town) {
        foreach (page_element_name, page_element in this.page_elements) {
            GSStoryPage.UpdateElement(page_element.reference, 1, page_element.text_method(vulcan_town));
        }
        GSStoryPage.SetDate(this.story_page, GSDate.GetCurrentDate());
    }
}
