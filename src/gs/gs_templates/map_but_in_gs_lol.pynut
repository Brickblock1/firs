class Region {
   /*
        Manages a list of areas
    */
    static areas = array(0);
    static negative_areas = array(0);
}

function Region::AddArea(area)
{
    this.areas.append(area);
}

function Region::AddNegativeArea(area)
{
    this.negative_areas.append(area);
}

function Region::GetUnifiedAreas()
{
    local result = array(0);
    foreach (area in this.areas) {
        foreach (xy_pair in area) {
            // prevent duplicates being added
            if (Region.FML(xy_pair, result) == -1) {
                result.append(xy_pair);
            }
        }
    }
    foreach (area in this.negative_areas) {
        foreach (xy_pair in area) {
            local index = Region.FML(xy_pair, result);
            if (index != -1) {
                result.remove(index);
            }
        }
    }
    return result
}

function Region::FML(new_xy_pair, target_array)
{
    // squirrel 2 apparently has no array.find() - not in docs, and attempting to use it is 'index not found'
    local counter = 0;
    foreach (xy_pair in target_array) {
        if ((xy_pair[0] == new_xy_pair[0]) && (xy_pair[1] == new_xy_pair[1])) {
            return counter
        }
        counter++;
    }
    return -1
}

class Area {
    /*
        Returns a list of tiles in a circular area around an origin tile
    */
    static function Circle(origin_tile, radius);
}

function Area::DeltaYFromDeltaXPythagoras(delta_x, radius)
{
    /*
        given a distance x, find an equivalent distance y which will sit on the circumference of a cirle with given radius
        this can be done by rearranging pythagoras so that b^2 = c^2 - a^2 where c is radius and a is delta_x
        if we wanted ellipses, that would be achieved by just scaling the return result by some factor
    */
    return sqrt((radius * radius) - (delta_x * delta_x)).tointeger();
}

function Area::Circle(origin_tile, radius)
{
    // this deliberately uses primitives, avoiding GSTileList etc and returning a simple array of (x, y) pairs
    // whether that's necessary or not I don't know, but there seems to be unresolved uncertainty around the performance of GS abstractions
    // also primitive code is long, but is easy to reason about, and also possibly port out of GS to base game
    //
    local origin_x = GSMap.GetTileX(origin_tile);
    local origin_y = GSMap.GetTileY(origin_tile);
    local result = array(0);
    // method using pythagoras to find y from each x using radius, then use y as the constraint for a tile file
    // this walks only the tiles that are explicitly needed and _may_ scale slightly better with larger radii, but eh, I have no fine-grained timing info
    for(local x = origin_x - radius; x <= origin_x + radius; x++) {
        local delta_y = Area.DeltaYFromDeltaXPythagoras(origin_x - x, radius);
        for(local y = origin_y - delta_y; y <= origin_y + delta_y; y++) {
            local xy_pair = array(0);
            xy_pair.push(x);
            xy_pair.push(y);
            result.push(xy_pair);
        }
    }
    /*
    // alternative method, walking _all_ tiles in a rect, then checking if they fall inside or outside the circle given by radius
    // as radius increases this _may_ scale poorly as it has to inspect and discard a relatively larger number of tiles, but eh, I have no fine-grained timing info
    for(local x = origin_x - radius; x <= origin_x + radius; x++) {
        for(local y = origin_y - radius; y <= origin_y + radius; y++) {
            // note that we work with square distance, so we square radius also
            local tile = GSMap.GetTileIndex(x, y);
            if (GSMap.DistanceSquare(tile, origin_tile) <= (radius * radius)) {
                local xy_pair = array(0);
                xy_pair.push(x);
                xy_pair.push(y);
                result.push(xy_pair);
            }
        }
    }
    */
    return result
}
