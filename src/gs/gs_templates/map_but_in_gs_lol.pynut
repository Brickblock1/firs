class Region {
   /*
        Manages a list of areas
    */
    static areas = array(0);
    static negative_areas = array(0);
}

function Region::AddArea(area)
{
    // !! there appears to be a max length for squirrel array, which I don't know how to determine yet
    // !! this will result in 'Maximum memory allocation exceeded' errors if attempting to add too many areas
    this.areas.append(area);
}

function Region::AddNegativeArea(area)
{
    this.negative_areas.append(area);
}

function Region::GetUnifiedAreas()
{
    Log.Info("unifying areas...");
    local time_start = GSDate.GetSystemTime();
    local result = array(0);
    ::index <- {}
    ::excluded_index <- {}

    foreach (negative_area in this.negative_areas) {
        foreach (xy_pair in negative_area) {
            local x = xy_pair[0];
            local y = xy_pair[1];
            if ((x in ::excluded_index) == false) {
                ::excluded_index[x] <- {};
            }
            if ((y in ::excluded_index[x]) == false) {
                ::excluded_index[x][y] <- null;
            }
        }
    }

    foreach (area in this.areas) {
        foreach (xy_pair in area) {
            local x = xy_pair[0];
            local y = xy_pair[1];
            // don't add excluded points
            if (x in ::excluded_index) {
                if (y in ::excluded_index[x]) {
                    // already exists, don't add it
                    continue;
                }
            }
            // don't add duplicates
            if ((x in ::index) == false) {
                ::index[x] <- {};
            }
            if (y in ::index[x]) {
                // xy_pair already exists, don't add it
                break;
            }
            else {
                ::index[x][y] <- null;
            }
            result.append(xy_pair);
        }
    }
    Log.Info("...areas unified. Elapsed time: " + (GSDate.GetSystemTime() - time_start) + " seconds");
    delete ::index
    delete ::excluded_index
    return result
}

class Area {
    /*
        Returns a list of tiles in a circular area around an origin tile
    */
    static function Circle(origin_tile, radius);

    /*
        Returns a list of tiles in a rect from two corner tiles
    */
    static function Rect(tile_from, tile_to);
}

function Area::DeltaYFromDeltaXPythagoras(delta_x, radius)
{
    /*
        given a distance x, find an equivalent distance y which will sit on the circumference of a cirle with given radius
        this can be done by rearranging pythagoras so that b^2 = c^2 - a^2 where c is radius and a is delta_x
        if we wanted ellipses, that would be achieved by just scaling the return result by some factor
    */
    return sqrt((radius * radius) - (delta_x * delta_x)).tointeger();
}

function Area::Circle(origin_tile, radius)
{
    // this deliberately uses primitives, avoiding GSTileList etc and returning a simple array of (x, y) pairs
    // whether that's necessary or not I don't know, but there seems to be unresolved uncertainty around the performance of GS abstractions
    // also primitive code is long, but is easy to reason about, and also possibly port out of GS to base game
    //
    local origin_x = GSMap.GetTileX(origin_tile);
    local origin_y = GSMap.GetTileY(origin_tile);
    local result = array(0);
    // method using pythagoras to find y from each x using radius, then use y as the constraint for a tile file
    // this walks only the tiles that are explicitly needed and _may_ scale slightly better with larger radii, but eh, I have no fine-grained timing info
    for (local x = origin_x - radius; x <= origin_x + radius; x++) {
        local delta_y = Area.DeltaYFromDeltaXPythagoras(origin_x - x, radius);
        for (local y = origin_y - delta_y; y <= origin_y + delta_y; y++) {
            local xy_pair = array(0);
            xy_pair.push(x);
            xy_pair.push(y);
            result.push(xy_pair);
        }
    }
    /*
    // alternative method, walking _all_ tiles in a rect, then checking if they fall inside or outside the circle given by radius
    // as radius increases this _may_ scale poorly as it has to inspect and discard a relatively larger number of tiles, but eh, I have no fine-grained timing info
    for(local x = origin_x - radius; x <= origin_x + radius; x++) {
        for(local y = origin_y - radius; y <= origin_y + radius; y++) {
            // note that we work with square distance, so we square radius also
            local tile = GSMap.GetTileIndex(x, y);
            if (GSMap.DistanceSquare(tile, origin_tile) <= (radius * radius)) {
                local xy_pair = array(0);
                xy_pair.push(x);
                xy_pair.push(y);
                result.push(xy_pair);
            }
        }
    }
    */
    return result
}

function Area::Rect(tile_from, tile_to)
{
    // we already have GSTileList.AddRectangle()
    // but this deliberately uses primitives, avoiding GSTileList etc and returning a simple array of (x, y) pairs
    // whether that's necessary or not I don't know, but there seems to be unresolved uncertainty around the performance of GS abstractions
    // also primitive code is long, but is easy to reason about, and also possibly port out of GS to base game
    //
    local x_1 = GSMap.GetTileX(tile_from);
    local y_1 = GSMap.GetTileY(tile_from);
    local x_2 = GSMap.GetTileX(tile_to);
    local y_2 = GSMap.GetTileY(tile_to);
    local result = array(0);
    // !! doesn't check for negative offsets between tile_from and tile_to
    for (local x = x_1; x <= x_2; x++) {
        for (local y = y_1; y <= y_2; y++) {
            local xy_pair = array(0);
            xy_pair.push(x);
            xy_pair.push(y);
            result.push(xy_pair);
        }
    }
    return result
}
