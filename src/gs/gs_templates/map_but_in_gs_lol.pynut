areas <- {}; // deprecate?
areas.towns <- {}; // deprecate?

function tile_walker()
{
    local time_start = GSDate.GetSystemTime();
    GSGame.Pause();
    Log.Error("Starting tile walk");
    local town_list = GSTownList();
    foreach (town, _ in town_list) {
        areas.towns[town] <- GSTileList();
    }
    local tile_list = GSTileList();
    // the map contains a row of void or water tiles around it (depending on freeform map edge settings), so our rect is pushed in by 1 tile row/col  on all sides
    tile_list.AddRectangle(GSMap.GetTileIndex(1, 1), GSMap.GetTileIndex(GSMap.GetMapSizeX() - 2, GSMap.GetMapSizeY() - 2));
    foreach (tile, _ in tile_list) {
        areas.towns[GSTile.GetClosestTown(tile)].AddTile(tile);
    }
    /*
    // stupid thing to draw a smiley face on the map
    Log.Info(GSTile.RaiseTile(GSMap.GetTileIndex(1, 1), GSTile.SLOPE_N | GSTile.SLOPE_W | GSTile.SLOPE_S));
    GSTile.LevelTiles(GSMap.GetTileIndex(1, 1), GSMap.GetTileIndex(GSMap.GetMapSizeX() - 2, GSMap.GetMapSizeY() - 2));
    for (local i = 0; i < 4; i++) {
        // eyes
        Log.Info(GSTile.RaiseTile(GSMap.GetTileIndex(10, 10), GSTile.SLOPE_N | GSTile.SLOPE_W | GSTile.SLOPE_S | GSTile.SLOPE_E));
        Log.Info(GSTile.RaiseTile(GSMap.GetTileIndex(20, 10), GSTile.SLOPE_N | GSTile.SLOPE_W | GSTile.SLOPE_S | GSTile.SLOPE_E));
        // smile
        GSTile.RaiseTile(GSMap.GetTileIndex(10, 20), GSTile.SLOPE_N);
        GSTile.RaiseTile(GSMap.GetTileIndex(11, 21), GSTile.SLOPE_N);
        GSTile.RaiseTile(GSMap.GetTileIndex(12, 22), GSTile.SLOPE_N);
        GSTile.RaiseTile(GSMap.GetTileIndex(13, 23), GSTile.SLOPE_N);
        GSTile.RaiseTile(GSMap.GetTileIndex(14, 24), GSTile.SLOPE_N);
        GSTile.RaiseTile(GSMap.GetTileIndex(15, 24), GSTile.SLOPE_N);
        GSTile.RaiseTile(GSMap.GetTileIndex(16, 24), GSTile.SLOPE_N);
        GSTile.RaiseTile(GSMap.GetTileIndex(17, 24), GSTile.SLOPE_N);
        GSTile.RaiseTile(GSMap.GetTileIndex(18, 23), GSTile.SLOPE_N);
        GSTile.RaiseTile(GSMap.GetTileIndex(19, 22), GSTile.SLOPE_N);
        GSTile.RaiseTile(GSMap.GetTileIndex(20, 21), GSTile.SLOPE_N);
        GSTile.RaiseTile(GSMap.GetTileIndex(21, 20), GSTile.SLOPE_N);
    }
    */
    Log.Info("Tile walk done. Elapsed time: " + (GSDate.GetSystemTime() - time_start));
    GSGame.Unpause();
}


class Area {
    /*
        Returns a list of tiles in a circular area around an origin tile
    */
    static function Circle(origin_tile, radius);
}

function Area::DeltaYFromDeltaXPythagoras(delta_x, radius)
{
    /*
        given a distance x, find an equivalent distance y which will sit on the circumference of a cirle with given radius
        this can be done by rearranging pythagoras so that b^2 = c^2 - a^2 where c is radius and a is delta_x
        if we wanted ellipses, that would be achieved by just scaling the return result by some factor
    */
    return sqrt((radius * radius) - (delta_x * delta_x)).tointeger();
}

function Area::Circle(origin_tile, radius)
{
    // this deliberately uses primitives, avoiding GSTileList etc and returning a simple array of (x, y) pairs
    // whether that's necessary or not I don't know, but there seems to be unresolved uncertainty around the performance of GS abstractions
    // also primitive code is long, but is easy to reason about, and also possibly port out of GS to base game
    //
    local origin_x = GSMap.GetTileX(origin_tile);
    local origin_y = GSMap.GetTileY(origin_tile);
    local result = array(0);
    // method using pythagoras to find y from each x using radius, then use y as the constraint for a tile file
    // this walks only the tiles that are explicitly needed and _may_ scale slightly better with larger radii, but eh, I have no fine-grained timing info
    for(local x = origin_x - radius; x <= origin_x + radius; x++) {
        local delta_y = Area.DeltaYFromDeltaXPythagoras(origin_x - x, radius);
        for(local y = origin_y - delta_y; y <= origin_y + delta_y; y++) {
            local xy_pair = array(0);
            xy_pair.push(x);
            xy_pair.push(y);
            result.push(xy_pair);
        }
    }
    /*
    // alternative method, walking _all_ tiles in a rect, then checking if they fall inside or outside the circle given by radius
    // as radius increases this _may_ scale poorly as it has to inspect and discard a relatively larger number of tiles, but eh, I have no fine-grained timing info
    for(local x = origin_x - radius; x <= origin_x + radius; x++) {
        for(local y = origin_y - radius; y <= origin_y + radius; y++) {
            // note that we work with square distance, so we square radius also
            local tile = GSMap.GetTileIndex(x, y);
            if (GSMap.DistanceSquare(tile, origin_tile) <= (radius * radius)) {
                local xy_pair = array(0);
                xy_pair.push(x);
                xy_pair.push(y);
                result.push(xy_pair);
            }
        }
    }
    */
    return result
}
